---
title: Closure part 2, nested component.
author: Haja Andriamaro
date: 2019-10-01
hero: ./images/nesting.jpg
excerpt: Second building bloc of closure
---

## Follow along from Part I

In my [previous article](../closure-part-1-lexical-scope), we have covered the concept of Lexical Scope, a building bloc to understand closure. 
We have seen that we can use a variable to keep track of the digits selected from the phone pad. There was also a "warning" that
at this stage, there is a big flaw in our code, even if we have the result we wanted (remembering each digit secletion). 
In this article, we will talk about how to fix the flaw with nested function, also a building bloc to understand and use closure.

### What's the flaw in our code?

At this stage we have the following code 
```javascript
// intialise the number to an empty string
let dialledNumber = '';

function phonePad (digit) {
  console.log('You stroke digit: ' + digit);
  // concatanate each new stroke to build the dialled number
  dialledNumber = dialledNumber.concat(digit);
  console.log('The phone number to call is: ' + digit);
}

phonePad('0'); 
phonePad('6');
phonePad('5');
```
It does the job, we are able to store each new digit in the "dialledNumber" variable. And because it is in the Lexical scope
of phonePad(), we have no error.

However, since "dialledNumber" act like a global variable (accessible/mutable from anywhere in the script), it is therefore "unprotected".
Which means that somewehere dow the line "dialledNumber" is called and used for another puropose ...

In addition to local variable, we will create a nested function (inside phonePad), we will call it "stoke". This nested function 
will be used for processing each stroke received by phonePad. 
We will move the concat operation inside the nested function (stoke) for that matter;

```javascript
function phonePad (strokedDigit) {
  // intialise the number to an empty string
  let dialledNumber = '';
  //declare the nested function
  function stroke (){
    // concatanate each new stroke to build the phone number
    dialledNumber = dialledNumber.concat(strokedDigit);
  }
  // invoke stroke
  stroke();
  console.log('You dialled this phone number: ' + dialledNumber);
}
```

OK, you got me, we still don't have any memory. But I want you to notice one very important concept in Javascript that you need to understand to truly understand Closure: Lexical scope.

### Step #4 understanding lexical scope

As you can see in the function above, we are invoking the "stroke" function without passing in any arguments. Yet, stroke function is still able to reach/find the variables that it needs (strokedDigit and dialledNumber) to execute... 

Basically the stroke() function will first search locally (within its curly bracket {} scope ) the declaration/initialisation of the variables to process. If it does not find them locally, it has the ability to search for them outside the {} scope. 
This is what is called Lexical scope (as far as I understand it as of today). 

However Lexical scope are only one way : inside/out search. So if you declare a variable inside the nested stroke() function and try to use it outside of stroke {} scope, it will generate an error. 
That is because of the inside->out only reach. In plain English (or Fran-glish) stroke() can see outside its {} bracket scope, but the outside cannot see what has been declared inside stroke().

The following will break the Pad

```javascript
function phonePad (strokedDigit) {
  ...
  function stroke (){
    // local variable declared inside stroke
    const localVariableToStroke = 'stoke local variable';
    console.log(localVariableToStroke);  
  }
  // Console output 'stroke local variable'
  stroke(); 
  // Error! localVariableToStroke not reachable !
  console.log(localVariableToStroke); 
}
```

### To be continued ...